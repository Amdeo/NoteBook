# C++标准

C++98到C++11经历了长达十年之久的积累，C++14则是作为对C++11的重要补充和优化，所有这些新标准中补充的特性，给C++这门语言注入新的活力。

C++1x，现在有C++11/14/17甚至还有C++20，C++一直在进行发展，增加很多新的元素，auto关键字的修改使我们更加有信心来操控复杂的模板的模板类型，同时还对语言运行期进行了大量的强化，Lambda 表达式的出现让 C++ 具有了『匿名函数』的『闭包』特性，而这一特性几乎在现代的编程语言（诸如 Python/Swift/... ）中已经司空见惯，右值引用的出现解决了 C++ 长期以来被人诟病的临时对象效率问题等等。

C++1x 为自身的标准库增加了非常多的工具和方法，诸如在语言层面上提供了 `std::thread` 支持了并发编程，在不同平台上不再依赖于系统底层的 API，实现了语言层面的跨平台支持；`std::regex`提供了完整的正则表达式支持等等。

## 怎么使用C++11或者C++14

使用-std=c++11的编译选项

```shell
g++ main.cpp -std=c++11
g++ main.cpp -std=c++14
```

## 被弃用的特性

- **如果一个类有析构函数，为其生成拷贝构造函数和拷贝赋值运算符的特性被弃用了。**

- **不再允许字符串字面值常量赋值给一个 char \*。如果需要用字符串字面值常量赋值和初始化一个 char \*，应该使用 const char \* 或者 auto。**

- **C++98 异常说明、 unexpected_handler、set_unexpected() 等相关特性被弃用，应该使用 noexcept。**

- **auto_ptr 被弃用，应使用 unique_ptr。**

- **register 关键字被弃用。**

- **bool 类型的 ++ 操作被弃用。**

- **C 语言风格的类型转换被弃用，应该使用 static_cast、reinterpret_cast、const_cast 来进行类型转换。**

## 与 C 的兼容性

```
extern "C"
```

extern "C"表示的一种编译和连接规约，而不是一种语言，仅指定编译和连接规约，但不影响语义，如果是C++项目指定了extern "C"，仍然要遵守C++的类型检测、参数转换等规则。它只是让程序按照类C的编译和连接规约来编译和链接



## nullptr 与 constexpr

### nullptr

nullptr出现的目的是为了替代了NULL，在某种意义上会把NULL和0视为同一种东西，这取决于编译器如何定义NULL，有的编译器会将NULL定义为((void*)0),

```C++
char *ch = NULL;
```

那么编译这行代码时，NULL只好被定义为0，二这将导致C++重载特性发生混乱

```C++
void foo(char *);
void foo(int);
```

对于这两个函数来说，如果 `NULL` 又被定义为了 `0` 那么 `foo(NULL);` 这个语句将会去调用 `foo(int)`，从而导致代码违反直观。

C++11引入了nullptr关键字，专门用来区分空指针，`nullptr` 的类型为 `nullptr_t`，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等或者不等的比较。

### constexpr

constexpr可以用来修饰变量、函数、构造函数，一旦以上任何元素被constexpr修饰，那么等于说是告诉编译器 “请大胆地将我看成编译时就能得出常量值的表达式去优化我”。

```C++
const int func() {
    return 10;
}
main(){
  int arr[func()];
}
//error : 函数调用在常量表达式中必须具有常量值

constexpr func() {
    return 10;
}
main(){
  int arr[func()];
}
//编译通过
```

则编译通过
编译期大胆地将func()做了优化，在编译期就确定了func计算出的值10而无需等到运行时再去计算。