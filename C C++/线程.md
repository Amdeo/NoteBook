## 创建线程

```C++
int pthread_create(
    pthread_t *pid,
    const pthread_attr_t *attr,
    void *(*start_routine),
    void *arg)

    
    /*
    第一参数：创建线程后返回的线程id
    第二参数：线程参数
    第三参数：线程函数
    第四参数：指向传给线程函数的参数
    
    返回值：0表示成功 非0表示失败
	*/

```



#### 创建一个不传参的线程



>主线程不等待子线程执行，主线程先退出，子线程没有机会执行。
>
>下面的列子，如果没有sleep，子线程根本不会有机会执行





```c++
#include <pthread.h>
#include <iostream>
#include <unistd.h>

using namespace std;

void *func(void * arg)
{
    cout<<"I am child thread"<<endl;
    return (void*)0;
}


int main()
{
    
    pthread_t tidp;
    int ret;

    ret = pthread_create(&tidp,NULL,func,NULL);

    if (ret)
    {
        cout <<"pthread create failed:"<< ret <<endl;
    }
    
    sleep(1); //如果没有行代码 main线程会先执行结束，子线程没有机会执行，程序就结束了

    cout<<"in main:thread "<<endl;

    return 0;
}

结果：

I am child thread
in main:thread 

```



创建有参的线程



```C++
#include <pthread.h>
#include <iostream>
#include <stdio.h>

using namespace std;

typedef struct{
    int age;
    char * name;
}MYSTRUCT;


//int型参数
void *thfunc(void *arg)
{
    int *pn = (int*)(arg);
    int n = *pn;

    cout<<"线程1的参数："<< n << endl;
    return (void *)0;   
}

//str型参数
void *strfunc(void * arg)
{
    char * str = (char *)(arg);
    cout<<"线程2的参数："<<str <<endl;
    return (void*)0;
}

//结构体参数
vois *intfunc(void* arg)
{
    
}

int main()
{
    pthread_t tidp;
    pthread_t tidp1;
    pthread_t tidp2;
    
    int n = 1;
    int ret = pthread_create(&tidp,NULL,thfunc,&n);
    if(ret)
    {
        cout<< "pthread_create failed:%d\n" <<endl;
        return -1;
    }
    pthread_join(tidp,NULL); //等待线程结束
    
    
    const char * str = "yuandongbin";
    int ret1 = pthread_create(&tidp1,NULL,strfunc,(void *)str);
    if(ret1)
    {
        cout<< "pthread_create failed:%d\n" <<endl;
        return -1;
    }
    pthread_join(tidp1,NULL); //等待线程结束

    MYSTRUCT mystruct;
    mystruct.
    
    
    cout<<"主线程结束"<<endl;
    return 0;

}
```

