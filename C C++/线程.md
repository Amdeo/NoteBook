[TOC]



## 线程API

```C++
//创建线程
int pthread_create(
    pthread_t *pid,
    const pthread_attr_t *attr,
    void *(*start_routine),
    void *arg)
/*
    第一参数：创建线程后返回的线程id
    第二参数：线程参数
    第三参数：线程函数
    第四参数：指向传给线程函数的参数

    返回值：0表示成功 非0表示失败
*/
    
//用来等待一个线程的结束
int pthread_join(
    pthread_t thread, 
    void **retval);
/*
参数一：thread: 线程标识符，以阻塞的方式等待thread指定的线程结束。
参数二：retval: 用户定义的指针，用来存储被等待线程的返回值。

返回值： 0代表成功。 失败，返回的则是错误号。
*/
```



### 创建一个不传参的线程



>主线程不等待子线程执行，主线程先退出，子线程没有机会执行。
>
>下面的列子，如果没有sleep，子线程根本不会有机会执行



```c++
#include <pthread.h>
#include <iostream>
#include <unistd.h>

using namespace std;

void *func(void * arg)
{
    cout<<"I am child thread"<<endl;
    return (void*)0;
}


int main()
{
    pthread_t tidp;
    int ret;

    ret = pthread_create(&tidp,NULL,func,NULL);
    if (ret)
    {
        cout <<"pthread create failed:"<< ret <<endl;
    }
    sleep(1); //如果没有行代码 main线程会先执行结束，子线程没有机会执行，程序就结束了
    cout<<"in main:thread "<<endl;
    return 0;
}

结果：

I am child thread
in main:thread 

```



### 创建有参数的线程



```C++
#include <pthread.h>
#include <iostream>
#include <stdio.h>
#include <string.h>

using namespace std;

typedef struct{
    int age;
    char * name;
}MYSTRUCT;


//int型参数
void *thfunc(void *arg)
{
    int *pn = (int*)(arg);
    int n = *pn;

    cout<<"线程1的参数："<< n << endl;
    return (void *)0;   
}

//str型参数
void *strfunc(void * arg)
{
    char * str = (char *)(arg);
    cout<<"线程2的参数："<<str <<endl;
    return (void*)0;
}

//结构体参数
void *structfunc(void* arg)
{
    MYSTRUCT * pMystruct = (MYSTRUCT*)(arg);
    cout<<"线程3的参数："<< "age= "<<pMystruct->age <<" name= "<<pMystruct->name<< endl;
    
    //返回值
    char *str = "ABC"
    return (void *)(&str);
}

int main()
{
    pthread_t tidp;
    pthread_t tidp1;
    pthread_t tidp2;
    
    int n = 1;
    int ret = pthread_create(&tidp,NULL,thfunc,&n);
    if(ret)
    {
        cout<< "pthread_create failed:%d\n" <<endl;
        return -1;
    }
    pthread_join(tidp,NULL); //等待线程结束
    
    
    const char * str = "yuandongbin";
    int ret1 = pthread_create(&tidp1,NULL,strfunc,(void *)str);
    if(ret1)
    {
        cout<< "pthread_create failed:%d\n" <<endl;
        return -1;
    }
    pthread_join(tidp1,NULL); //等待线程结束

    MYSTRUCT mystruct;
    mystruct.age = 26;
    mystruct.name = new char[10];
    strcpy(mystruct.name,"yuandongbin");
    
    int ret2 = pthread_create(&tidp2,NULL,structfunc,(void *)&mystruct);
    if(ret2)
    {
        cout<< "pthread_create failed:%d\n" <<endl;
        return -1;
    }
    
    
    pthread_join(tidp2,NULL);
    
    cout<<"主线程结束"<<endl;
    return 0;
}

/*
输出结果：

线程1的参数：1
线程2的参数：yuandongbin
线程3的参数：age= 26 name= yuandongbin
主线程结束

*/
```

