
[TOC]

# 编程问题



## 1.类class和结构体struct区别
> class和struct唯一的不同就是，class默认的访问方式是private，struct默认访问方式为public



## 2.指针作为形式参数，什么时候用一级指针？ 什么时候用二级指针?
形参是实参的拷贝，所以在函数中修改不会修改实参的值，但是通过指针修改指针指向的内存是可以的。

```C++

#include <iostream>
#include <stdio.h>

using namespace std;

//传入一级指针 修改指针指向的值
void func(int *p)
{
    *p = 2;
}

//传入一级指针 修改指针的值

void func1(int *p)
{
    //在函数中p是一个局部变量，修改的局部变量p，对原来的那个p没有影响
    cout<<"尝试修改p的值"<<endl;
    p = (int *)0x123345566;
}

//传入二级指针，就可以修改一级指针了
void func2(int **p)
{
    cout<<"" <<endl;
    *p = (int *)0x111313131;
}

int main()
{
    int a = 1;
    int *p = &a;
    func(p);
    func1(p);
    func2(&p);
    return 0;
}
```



## 3.数组的地址

**一维数组**：

```
int a[] = {1,2,3,4,5};//一维数组
```

> 我经常对数组地址和元素地址混淆，虽然 a = &a 在值上是一样的，它们在层级上是不同的，&a就是整个数组的地址，a就是数组首元素的地址，a+1就是第二给元素的地址，第三、第四元素，依次加1。



一维数组元素的值和地址转换：

```
a[0] == *(a+0) == *a
a[1] == *(a+1) 
```

**二维数组**

```
int a[][3]={1,2,3,4,5,6,7,8,9};
```

&a是整个二维数组的地址

a就是数组首元素的地址，a+1就是第二给元素的地址，第三、第四元素，依次加1。

与一维数组比较，可以将二维数组看作3个一维数组,

```
a1[] = {1,2,3};		a2[] = {4,5,6};		a3[] = {7,8,9}

int a[][3] = {a1,a2,a3} 
a = a1 = *a1

a+1 == a2
```

&a[0]第一组数组的首地址， `&a == a == &a`

&a[1]第二组数组的首地址，即整个二维的数组第四个元素地址 `&a[1] == &a[1][0] == a+1`

二维数组元素的值和地址转换：

```
a = a[0]  a+1 = a[1]  a+2 = a[2]

*(a[1]+1) == *(*(a+1)+1) = a[1][1]
```



```c++
#include <iostream>
#include <pthread.h>
#include <unistd.h>

using namespace std;

template <class T>
void print_point(T *p)
{
    cout<< static_cast<void *>(p) <<endl;
}


int main() {
    int a[] = {1,2,3,4,5};
    print_point(a);
    print_point(a+1);
    print_point(&a);
    print_point(&a+1);
    return 0;
}

/*
结果：
0x7fffffb6bdf0
0x7fffffb6bdf4
0x7fffffb6bdf0
0x7fffffb6be04
*/
```



```C++
#include <iostream>
#include <pthread.h>
#include <unistd.h>
#include "common.h"

using namespace std;

template <class T>
void print_point(T *p)
{
    cout<< static_cast<void *>(p) <<endl;
}

template <class T>
void print_value(T value)
{
    cout<< value <<endl;
}

int main() {
//    int a[] = {1,2,3,4,5};
//    print_point(a);
//    print_point(a+1);
//    print_point(&a);
//    print_point(&a+1);

    int a[][3]={1,2,3,4,5,6,7,8,9};
    print_point(a);
    print_point(a[0]);

    print_point(a+1);
    print_point(*(a+1));
    print_point(a[1]);
    print_point(a[1]+1);
    print_value(*(a[1]+1));
    print_value(*(*(a+1)+1));

    print_point(a+2);
    print_point(a[2]);

    print_point(&a);
    print_point(&a+1);



    print_value(*(a[0]));
    print_value(*(a[1]));
    return 0;
}

/*
结果：
0x7fffcb97faf0
0x7fffcb97faf0
0x7fffcb97fafc
0x7fffcb97fafc
0x7fffcb97fafc
0x7fffcb97fb00
5
5
0x7fffcb97fb08
0x7fffcb97fb08
0x7fffcb97faf0
0x7fffcb97fb14
1
4
*/
```



## 4.typename 和 class

`typename`和`class`是模板中经常使用的两个关键词 ，在模板定义的时候没有什么区别。以前用的是 class，后来 c++ 委员会加入了 typename。因为历史原因，两个是可以通用的。对有些程序员来说，在定义类模板的时候，常常使用 class 作为关键字，增加代码可读性。其它则用 typename，上面的代码大都遵循这样的标准，但是并无强制规定。但是如果二者没有差别，为什么还要加入typename呢？**c++标准委员会不会增加无用的特性**，让我们来看一个例子：

```C++
class Myclass{
    public:
        Myclass();
        typedef int test;  //定义类型别名
}
template <class T>
class Myclass2{
    public:
        Myclass2();
        T::test *a  // 声明一个指向T::test类型的指针。
        //   typename T::test * a
}
```

以上的代码没有全部写完，大家觉得编译器能够过吗？答案是不能,因为在 c++ 中，允许我们在类中定义一个类型别名，且使用的时候和类名访问类成员的方法一样。这样编译器在编译的时候就会产生二义性，它根本不知道这是一个类型还是别名，所以我们加上 typename 显式说明出来。当然如果这里没有二义性，比如`Myclass ::test * a` ,加上 typename 是会报错的。此外，在 class 的 STL 底层还有一个特性，用于保留模板参数，但是在 c++17 中已经舍弃，所以我们没有讲。

## 如何判断大小端（字节序）
```C++
#include <iostream>
#include <stdio.h>
using namespace std;

int main()
{
	int a = 0x12345678;
	char *p = (char *)&a;

	printf("0x%x\n", *p);
	if (*p == 0x12)
	{
		cout<<"This is a big endian" <<endl;
	}
	else
	{
		cout << "This ia a small endian" << endl;
	}
	return 0;
}

```
