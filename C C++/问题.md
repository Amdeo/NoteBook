* [编程问题](#%E7%BC%96%E7%A8%8B%E9%97%AE%E9%A2%98)
  * [1\.类class和结构体struct区别](#1%E7%B1%BBclass%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93struct%E5%8C%BA%E5%88%AB)
  * [2\.指针作为形式参数，什么时候用一级指针？ 什么时候用二级指针?](#2%E6%8C%87%E9%92%88%E4%BD%9C%E4%B8%BA%E5%BD%A2%E5%BC%8F%E5%8F%82%E6%95%B0%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88)
  * [3\.数组的地址](#3%E6%95%B0%E7%BB%84%E7%9A%84%E5%9C%B0%E5%9D%80)
  * [4\.typename 和 class](#4typename-%E5%92%8C-class)
  * [5\.如何判断大小端（字节序）](#5%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%A4%A7%E5%B0%8F%E7%AB%AF%E5%AD%97%E8%8A%82%E5%BA%8F)
  * [6\.C语言中关于float、double、long double精度及数值范围](#6c%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%85%B3%E4%BA%8Efloatdoublelong-double%E7%B2%BE%E5%BA%A6%E5%8F%8A%E6%95%B0%E5%80%BC%E8%8C%83%E5%9B%B4)
  * [7\.如何在namespace中写代码](#7%E5%A6%82%E4%BD%95%E5%9C%A8namespace%E4%B8%AD%E5%86%99%E4%BB%A3%E7%A0%81)

# 编程问题



## 1.类class和结构体struct区别
> class和struct唯一的不同就是，class默认的访问方式是private，struct默认访问方式为public



## 2.指针作为形式参数，什么时候用一级指针？ 什么时候用二级指针?
形参是实参的拷贝，所以在函数中修改不会修改实参的值，但是通过指针修改指针指向的内存是可以的。

```C++

#include <iostream>
#include <stdio.h>

using namespace std;

//传入一级指针 修改指针指向的值
void func(int *p)
{
    *p = 2;
}

//传入一级指针 修改指针的值

void func1(int *p)
{
    //在函数中p是一个局部变量，修改的局部变量p，对原来的那个p没有影响
    cout<<"尝试修改p的值"<<endl;
    p = (int *)0x123345566;
}

//传入二级指针，就可以修改一级指针了
void func2(int **p)
{
    cout<<"" <<endl;
    *p = (int *)0x111313131;
}

int main()
{
    int a = 1;
    int *p = &a;
    func(p);
    func1(p);
    func2(&p);
    return 0;
}
```



## 3.数组的地址

**一维数组**：

```
int a[] = {1,2,3,4,5};//一维数组
```

> 我经常对数组地址和元素地址混淆，虽然 a = &a 在值上是一样的，它们在层级上是不同的，&a就是整个数组的地址，a就是数组首元素的地址，a+1就是第二给元素的地址，第三、第四元素，依次加1。

- a就是a[0]的地址，a+1就是a[1]的地址
- &a是整个a[]的首地址，

一维数组元素的值和地址转换：

```
a[0] == *(a+0) == *a
a[1] == *(a+1) 
```

**二维数组**

```
int a[][3]={1,2,3,4,5,6,7,8,9};
```

&a是整个二维数组的地址

a就是数组首元素的地址，a+1就是第二给元素的地址，第三、第四元素，依次加1。

与一维数组比较，可以将二维数组看作3个一维数组,

```
a1[] = {1,2,3};		
a2[] = {4,5,6};		
a3[] = {7,8,9}

int a[][3] = {&a1,&a2,&a3}  //这里放的是整个数组的地址
------------
a = &a1
a + 1 = &a2
a + 2 = &a3
a[0] = a1 //首元素的地址
a[1] = a2
a[2] = a3
和一维数组一样，a是首元素的地址，移动指针可以指向后面元素
-----------
a[0][0] = *(*(a + 0) + 0)
```

二维数组元素的值和地址转换：

```c++
#include <iostream>
#include <pthread.h>
#include <unistd.h>

using namespace std;

template <class T>
void print_point(T *p)
{
    cout<< static_cast<void *>(p) <<endl;
}


int main() {
    int a[] = {1,2,3,4,5};
    print_point(a);
    print_point(a+1);
    print_point(&a);
    print_point(&a+1);
    return 0;
}

/*
结果：
0x7fffffb6bdf0
0x7fffffb6bdf4
0x7fffffb6bdf0
0x7fffffb6be04
*/
```



```C++
#include <iostream>
#include <pthread.h>
#include <unistd.h>
#include "common.h"

using namespace std;

template <class T>
void print_point(T *p)
{
    cout<< static_cast<void *>(p) <<endl;
}

template <class T>
void print_value(T value)
{
    cout<< value <<endl;
}

int main() {
//    int a[] = {1,2,3,4,5};
//    print_point(a);
//    print_point(a+1);
//    print_point(&a);
//    print_point(&a+1);

    int a[][3]={1,2,3,4,5,6,7,8,9};
    print_point(a);
    print_point(a[0]);

    print_point(a+1);
    print_point(*(a+1));
    print_point(a[1]);
    print_point(a[1]+1);
    print_value(*(a[1]+1));
    print_value(*(*(a+1)+1));

    print_point(a+2);
    print_point(a[2]);

    print_point(&a);
    print_point(&a+1);



    print_value(*(a[0]));
    print_value(*(a[1]));
    return 0;
}

/*
结果：
0x7fffcb97faf0
0x7fffcb97faf0
0x7fffcb97fafc
0x7fffcb97fafc
0x7fffcb97fafc
0x7fffcb97fb00
5
5
0x7fffcb97fb08
0x7fffcb97fb08
0x7fffcb97faf0
0x7fffcb97fb14
1
4
*/
```



## 4.typename 和 class

`typename`和`class`是模板中经常使用的两个关键词 ，在模板定义的时候没有什么区别。以前用的是 class，后来 c++ 委员会加入了 typename。因为历史原因，两个是可以通用的。对有些程序员来说，在定义类模板的时候，常常使用 class 作为关键字，增加代码可读性。其它则用 typename，上面的代码大都遵循这样的标准，但是并无强制规定。但是如果二者没有差别，为什么还要加入typename呢？**c++标准委员会不会增加无用的特性**，让我们来看一个例子：

```C++
class Myclass{
    public:
        Myclass();
        typedef int test;  //定义类型别名
}
template <class T>
class Myclass2{
    public:
        Myclass2();
        T::test *a  // 声明一个指向T::test类型的指针。
        //   typename T::test * a
}
```

以上的代码没有全部写完，大家觉得编译器能够过吗？答案是不能,因为在 c++ 中，允许我们在类中定义一个类型别名，且使用的时候和类名访问类成员的方法一样。这样编译器在编译的时候就会产生二义性，它根本不知道这是一个类型还是别名，所以我们加上 typename 显式说明出来。当然如果这里没有二义性，比如`Myclass ::test * a` ,加上 typename 是会报错的。此外，在 class 的 STL 底层还有一个特性，用于保留模板参数，但是在 c++17 中已经舍弃，所以我们没有讲。

## 5.如何判断大小端（字节序）



| 内存地址 | 0x4000 8000（低地址） | 0x4000 8001 | 0x4000 8002 | 0x4000 8003（高地址） |
| -------- | --------------------- | ----------- | ----------- | --------------------- |
| 大端模式 | `0x12（高字节）`      | `0x34`      | `0x56`      | `0x78（低字节）`      |
| 小端模式 | `0x78（低字节）`      | `0x56`      | `0x34`      | `0x12（高字节）`      |



```C++
#include <iostream>
#include <stdio.h>
using namespace std;

int main()
{
	int a = 0x12345678;
	char *p = (char *)&a;

	printf("0x%x\n", *p);
	if (*p == 0x12)
	{
		cout<<"This is a big endian" <<endl;
	}
	else
	{
		cout << "This ia a small endian" << endl;
	}
	return 0;
}

```

6.C语言中关于float、double、long double精度及数值范围
---

float double取值范围如下：

对于单精度浮点数（float）来说，有一位符号位，指数位共8位，尾数共23位。指数能够表示的指数范围为-128~127。尾数为23位。当尾数全1时再加上小数点前面的1，指数取到最大正数127（8位，正数最大127，负数最小-128）,浮点数取得正数的最大值。

+1.111111111111111111111*2^127（1.后面23个1，由于尾数的范围1～2，其最高位总为1，故只需存取小数部分，所以小数为是23位1），约等于2*2^127=3.4*10^38。为3.4*10^38负数亦然。

Double的计算与此类似，double的符号位为63位，指数为62～52位，共11位。表示的范围为-1024～1023。尾数为51～0。表示的范围为+1.111111111111111111111*2^1023（1.后面52个1）为1.7*10^308。负数亦然。



## 7.如何在namespace中写代码

func.h

```C++
//
// Created by amdeo on 2019-07-02.
//

#ifndef LINUX_C_FUNC_H
#define LINUX_C_FUNC_H

//声明一个命名空间
namespace ydb
{
    void process_test();
}


#endif //LINUX_C_FUNC_H

```

func.cpp

```C++

//
// Created by amdeo on 2019-07-02.
//
#include "func.h"
#include <iostream>
#include <unistd.h>
#include "common.h"
#include<unistd.h>
#include<sys/types.h>

//在cpp文件中 直接使用 (::)实现函数
void ydb::process_test()
{
    pid_t pid;
    int i = 0;
    cout<<"before fork\n";
    pid = fork();
    cout<<"after fork\n";
    if (pid < 0)
    {
        cout<< "fork failed" <<endl;
    }
    else if(pid == 0)   //子进程
    {
        while (i<10) {
            cout << "I am child,i = " << i << endl;
            i += 1;
        }
        cout << "child process is " << getpid() << endl;
    }
    else{
        //父进程
        //sleep(10);
        while (i<10){
            cout<<"I am parent,i = "<<i<<endl;
            i += 2;
        }

        cout<< "parent process is " <<getpid()<<endl;
    }
    cout<<"exit process\n";
}
```

main.cpp

```C++
#include "common.h"
#include "func.h"

int main() {
  	//在main函数中直接使用（ydb::）调用
    ydb::process_test();
    return 0;
}
```
