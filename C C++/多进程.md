[TOC]



参考：<https://www.cnblogs.com/tshua/p/5756465.html>



# API

## 进程的创建

### fork

C++的fork函数用来“复制”一份主程序，即创建主进程的子进程。调用fork的同时，我的理解是，已经在内存中创建了“副本”进程，同时返回pid，所以在返回值之前，已经是主进程和子进程同时在运行了（如果fork成功的话），这样，在程序的运行过程中，一次fork返回了两次值，在父进程中，fork返回新创建子进程的进程ID，在子进程中，fork返回0，这时候就能够同时跑两个进程了。 

![1560693482182](C:\Users\77465\AppData\Roaming\Typora\typora-user-images\1560693482182.png)

![1560693577868](C:\Users\77465\AppData\Roaming\Typora\typora-user-images\1560693577868.png)



![1560693792485](C:\Users\77465\AppData\Roaming\Typora\typora-user-images\1560693792485.png)



```C++
//创建进程
pid_t fork (void)；

//获取进程ID
pid_t getpid();

//判断进程是否运行
if(0 == kill(pid,0));

//阻塞函数

```

```C++
#include <iostream>
#include <unistd.h>
#include "common.h"
#include<unistd.h>
#include<sys/types.h>

using namespace std;

int main() {
    pid_t pid;
    int i = 0;
    cout<<"before fork\n";
    pid = fork();
    cout<<"after fork\n";
    if (pid < 0)
    {
        cout<< "fork failed" <<endl;
    }
    else if(pid == 0)   //子进程
    {
        while (i<10) {
            cout << "I am child,i = " << i << endl;
            i += 1;
        }
        cout << "child process is " << getpid() << endl;
    }
    else{
        //父进程
        //sleep(10);
        while (i<10){
            cout<<"I am parent,i = "<<i<<endl;
            i += 2;
        }

        cout<< "parent process is " <<getpid()<<endl;
    }
    cout<<"exit process\n";
    return 0;
}

/*
before fork
after fork
after fork
I am parent,i = 0
I am parent,i = 2
I am parent,i = 4
I am parent,i = 6
I am parent,i = 8
parent process is 2066
exit process
I am child,i = 0
I am child,i = 1
I am child,i = 2
I am child,i = 3
I am child,i = 4
I am child,i = 5
I am child,i = 6
I am child,i = 7
I am child,i = 8
I am child,i = 9
child process is 2067
exit process
*/
```

我们从上面的结果中看出，fork之后的代码执行了两次，子进程是从fork之后执行的，但是变量i在fork之前就定义了，在父子进程中互不影响，说明子进程复制资源和代码，并且资源是独立的。



#### fork出来的子进程会继承父进程哪些性质

子进程继承如下性质。

1）、实际用户ID，实际组ID，有效用户ID，有效组ID，添加组ID。

2）、进程组ID（下一篇讲）。

3）、对话组ID（下一篇讲）。

4）、控制终端（下一篇讲）。

5）、设置用户ID标志和设置组ID标志。

6）、当前工作目录。

7）、根目录。

8）、文件创建方式屏蔽字。

9）、信号屏蔽额排列（第10篇讲）。

10）、对任意一打开文件描述符的在执行是的关闭标志。

11）、环境变量。

12）、连接的共享存储段。

13）、资源限制（如文件描述符个数限制）。



#### 父子进程之间的区别

1）、fork返回值不同。

2）、进程ID。

3）、不同的父进程ID。

4）、子进程的用户时间，系统时间，时钟时间都被设置为0.

5）、父进程设置的锁，子进程不能被继承。

6）、子进程从父进程继承而来的味觉警告会被清除。

7）、子进程从父进程继承来的未决信号集集会被清零。



### exec





### system